# Values in the form @VAR@ are prototype variables
# They will be replaced by CMake

set( _PACKAGE_VERSION_TYPE		"@_VERSION_TYPE@" )
set( _PACKAGE_VERSION_NAME		"@_VERSION_NAME@" )
set( _PACKAGE_VERSION_MAJOR		@_VERSION_MAJOR@ )
set( _PACKAGE_VERSION_MINOR		@_VERSION_MINOR@ )
set( _PACKAGE_VERSION_REVISION	@_VERSION_REVISION@ )
set( _PACKAGE_HWARCH			"@VISTA_HWARCH@" )

set( PACKAGE_VERSION "@_VERSION_MAJOR@.@_VERSION_MINOR@.@_VERSION_REVISION@" )

set( PACKAGE_VERSION_EXT "Type @_VERSION_TYPE@ - Name @_VERSION_NAME@ - @_VERSION_MAJOR@.@_VERSION_MINOR@.@_VERSION_REVISION@ - HWARCH: ${VISTA_HWARCH}" )

# the cmake native versioning system: just allows an exact match with MAJOR.MINOR.REVISION - just works for releases!

if( _PACKAGE_VERSION_TYPE STREQUAL "RELEASE" )
	set( PACKAGE_VERSION_EXACT TRUE )
	set( PACKAGE_VERSION_COMPATIBLE TRUE )
	set( PACKAGE_VERSION_UNSUITABLE FALSE )
	
	if( NOT PACKAGE_FIND_VERSION_MAJOR VERSION_EQUAL _PACKAGE_VERSION_MAJOR )
		set( PACKAGE_VERSION_EXACT FALSE )
		set( PACKAGE_VERSION_COMPATIBLE FALSE )
	endif( NOT PACKAGE_FIND_VERSION_MAJOR VERSION_EQUAL _PACKAGE_VERSION_MAJOR )
	
	if( PACKAGE_FIND_VERSION_COUNT GREATER 1 )
		if( NOT PACKAGE_FIND_VERSION_MINOR VERSION_EQUAL _PACKAGE_VERSION_MINOR )
			set( PACKAGE_VERSION_EXACT FALSE )
			set( PACKAGE_VERSION_COMPATIBLE FALSE )
		endif( NOT PACKAGE_FIND_VERSION_MINOR VERSION_EQUAL _PACKAGE_VERSION_MINOR )
	endif( PACKAGE_FIND_VERSION_COUNT GREATER 1 )
	
	if( PACKAGE_FIND_VERSION_COUNT GREATER 2 )
		if( NOT PACKAGE_FIND_VERSION_PATCH VERSION_EQUAL _PACKAGE_VERSION_REVISION )
			set( PACKAGE_VERSION_EXACT FALSE )
			set( PACKAGE_VERSION_COMPATIBLE FALSE )
		endif( NOT PACKAGE_FIND_VERSION_PATCH VERSION_EQUAL _PACKAGE_VERSION_REVISION )
	endif( PACKAGE_FIND_VERSION_COUNT GREATER 2 )	
	
else( _PACKAGE_VERSION_TYPE STREQUAL "RELEASE" )
	set( PACKAGE_VERSION_EXACT FALSE )
	set( PACKAGE_VERSION_COMPATIBLE FALSE )
	set( PACKAGE_VERSION_UNSUITABLE TRUE )
endif( _PACKAGE_VERSION_TYPE STREQUAL "RELEASE" )




# a special macro for loading the the custom versioned file, since luckily CMakes versioning can
# handle just nothing but versions like 2.3.11.42 - absolutely perfect for development versions and branching
# we'd prefer to have the option to use find_package with a more elaborate versioning, including HEAD/TAG/BRANCHNAMES
# and version ranges
# if the versionmatches, the flag is NOT ALTERED! but only set to FALSE if it fails

macro( check_valid_subversion INPUT_SUBVERSION OWN_SUBVERSION MATCH_FLAG )
	set( _LOCAL_MATCH_FLAG FALSE )
	
	if( NOT INPUT_SUBVERSION )
		#fine for us
		set( _LOCAL_MATCH_FLAG TRUE )
	elseif( ${INPUT_SUBVERSION} EQUAL ${OWN_SUBVERSION} )
		set( _LOCAL_MATCH_FLAG TRUE )
	else( ${INPUT_SUBVERSION} EQUAL ${OWN_SUBVERSION} )
	
		#check if it is NUMBER+ - anything equal or bigger to number
		string( REGEX MATCH "([0-9]+)\\+$" _STRING_IS_MIN ${INPUT_SUBVERSION} )
		if( _STRING_IS_MIN )
			if( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_0 ) OR ( ${OWN_SUBVERSION} GREATER CMAKE_MATCH_0 ) )
				set( _LOCAL_MATCH_FLAG TRUE )
			endif( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_0 ) OR ( ${OWN_SUBVERSION} GREATER CMAKE_MATCH_0 ) )
		else( _STRING_IS_MIN )
		
			#check if it is NUMBER-NUMBER - an explicit range
			string( REGEX MATCH "([0-9]+)\\-([0-9]+)$" _STRING_IS_RANGE ${INPUT_SUBVERSION} )
			if( _STRING_IS_RANGE )
				if( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_1 ) OR ( ${OWN_SUBVERSION} GREATER CMAKE_MATCH_1 ) )
					if( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_2 ) OR ( ${OWN_SUBVERSION} LESS CMAKE_MATCH_2 ) )
						set( _LOCAL_MATCH_FLAG TRUE )
					endif( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_2 ) OR ( ${OWN_SUBVERSION} LESS CMAKE_MATCH_2 ) )
				endif( ( ${OWN_SUBVERSION} EQUAL CMAKE_MATCH_1 ) OR ( ${OWN_SUBVERSION} GREATER CMAKE_MATCH_1 ) ) 
			endif( _STRING_IS_RANGE )			
		
		endif( _STRING_IS_MIN  )
	endif( NOT INPUT_SUBVERSION )
	
	if( NOT _LOCAL_MATCH_FLAG )
		set( MATCH_FLAG FALSE )
	endif( NOT _LOCAL_MATCH_FLAG )
endmacro( check_valid_subversion )

macro( check_custom_versioned VERSION_NAME VERSION_MATCH_FLAG )

	set( _VERSION_MATCH FALSE )
	
	if( VISTA_HWARCH STREQUAL _PACKAGE_HWARCH )
		
		set( _IN_NAME		"" )
		set( _IN_MAJOR		"" )
		set( _IN_MINOR		"" )
		set( _IN_REVISION	"" )
		
		# first, we decompose the input		
		set( _REMAINING_VERSION ${VERSION_NAME} )
		
		if( _REMAINING_VERSION )
			string( REGEX MATCH "([a-zA-Z]+[a-zA-Z0-9_\\-]*)([\\.0-9\\+\\-]*)$" MATCH_SUCCESS ${_REMAINING_VERSION} )
			if( MATCH_SUCCESS )
				# we found a textual start -> Name
				set( _IN_NAME ${CMAKE_MATCH_1} )
				set( _REMAINING_VERSION ${CMAKE_MATCH_2} )
			endif( MATCH_SUCCESS )
		endif( _REMAINING_VERSION )
		
		if( _REMAINING_VERSION )
			string( REGEX MATCH "([0-9\\+\\-]+)([\\.0-9\\+\\-]*)$" MATCH_SUCCESS ${_REMAINING_VERSION} )
			if( MATCH_SUCCESS )
				# we found a textual start -> Name
				set( _IN_MAJOR ${CMAKE_MATCH_1} )
				set( _REMAINING_VERSION ${CMAKE_MATCH_2} )
			endif( MATCH_SUCCESS )
		endif( _REMAINING_VERSION )
		
		if( _REMAINING_VERSION )	
			string( REGEX MATCH "([0-9\\+\\-]+)([\\.0-9\\+\\-]*)$" MATCH_SUCCESS ${_REMAINING_VERSION} )
			if( MATCH_SUCCESS )
				# we found a textual start -> Name
				set( _IN_MINOR ${CMAKE_MATCH_1} )
				set( _REMAINING_VERSION ${CMAKE_MATCH_2} )
			endif( MATCH_SUCCESS )
		endif( _REMAINING_VERSION )
		
		if( _REMAINING_VERSION )	
			string( REGEX MATCH "([0-9\\+\\-]+)([\\.0-9\\+\\-]*)$" MATCH_SUCCESS ${_REMAINING_VERSION} )
			if( MATCH_SUCCESS )
				# we found a textual start -> Name
				set( _IN_REVISION ${CMAKE_MATCH_1} )
				set( _REMAINING_VERSION ${CMAKE_MATCH_2} )
			endif( MATCH_SUCCESS )	
		endif( _REMAINING_VERSION )
		
		# option1: for RELEASE versions, valid parameters are
		#   - RELEASENAME
		#   - RELEASENAME.REVISION[+ | -RANGE]
		#   - MAJOR[+ | -RANGE]
		#   - MAJOR.MINOR[+ | -RANGE]
		#   - MAJOR.MINOR.REVISION[+ | -RANGE]
		if( _PACKAGE_VERSION_TYPE STREQUAL "RELEASE" )
			if( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
				# we start with the release name, just check for revision
				set( _VERSION_MATCH TRUE )
				check_valid_subversion( _IN_MAJOR _PACKAGE_VERSION_MINOR _VERSION_MATCH )
				
			else( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
				# check for the full monty
				set( _VERSION_MATCH TRUE )
				check_valid_subversion( _IN_MAJOR _PACKAGE_VERSION_MAJOR _VERSION_MATCH )
				check_valid_subversion( _IN_MINOR _PACKAGE_VERSION_MINOR _VERSION_MATCH )
				check_valid_subversion( _IN_REVISION _PACKAGE_VERSION_REVISION _VERSION_MATCH )
			endif( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )

		# option2: for HEAD versions, valid parameters are
		#   - HEAD
		#   - HEAD.MAJOR[+ | -RANGE]
		#   - HEAD.MAJOR.MINOR[+ | -RANGE]
		#   - HEAD.MAJOR.MINOR.REVISION[+ | -RANGE]	
		elseif( _PACKAGE_VERSION_TYPE STREQUAL "HEAD" )
			if( _IN_NAME STREQUAL "HEAD" )
				# we still need to check for major.minor.revision
				set( _VERSION_MATCH TRUE )
				check_valid_subversion( _IN_MAJOR _PACKAGE_VERSION_MAJOR _VERSION_MATCH )
				check_valid_subversion( _IN_MINOR _PACKAGE_VERSION_MINOR _VERSION_MATCH )
				check_valid_subversion( _IN_REVISION _PACKAGE_VERSION_REVISION _VERSION_MATCH )
			endif( _IN_NAME STREQUAL "HEAD" )

		# option3: for BRANCH versions, valid parameters are
		#	- BRANCHNAME
		elseif( _PACKAGE_VERSION_TYPE STREQUAL "BRANCH" )	
			if( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
				set( _VERSION_MATCH TRUE )
			endif( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
			
		# option4: for TAG versions, valid parameters are
		#	- TAGNAME
		elseif( _PACKAGE_VERSION_TYPE STREQUAL "TAG" )
			if( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
				set( _VERSION_MATCH TRUE )
			endif( _PACKAGE_VERSION_NAME STREQUAL _IN_NAME )
			
		endif(_PACKAGE_VERSION_TYPE STREQUAL "RELEASE" )
		
		set( ${VERSION_MATCH_FLAG} ${_VERSION_MATCH} )
		
	else( else VISTA_HWARCH STREQUAL _PACKAGE_HWARCH )
		set( ${VERSION_MATCH_FLAG} FALSE )
	endif( VISTA_HWARCH STREQUAL _PACKAGE_HWARCH )
	
endmacro( check_custom_versioned )




